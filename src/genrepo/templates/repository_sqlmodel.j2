"""Generated by Genrepo

Auto-generated repository for {{ model_class }} (SQLModel).
"""

from __future__ import annotations

from typing import Optional, Any

{% if is_async %}
from sqlmodel.ext.asyncio.session import AsyncSession as Session
from sqlmodel import select
{% else %}
from sqlmodel import Session, select
{% endif %}
from sqlalchemy import func

from {{ model_module }} import {{ model_class }}


class {{ model_name }}Repository:
    """Repository for {{ model_class }}.

    Generated CRUD methods are controlled by configuration. Methods follow
    simple defaults and are intended as a starting point.
    """

    class NotFoundError(Exception):
        """Raised when an entity is not found."""

{% if 'get' in methods %}
{% if is_async %}
    async def get(self, session: Session, id: {{ id_type }}) -> Optional[{{ model_class }}]:
{% else %}
    def get(self, session: Session, id: {{ id_type }}) -> Optional[{{ model_class }}]:
{% endif %}
        """Return a single {{ model_class }} by primary key or None."""
        stmt = select({{ model_class }}).where(getattr({{ model_class }}, "{{ id_field }}") == id)
{% if is_async %}
        return (await session.exec(stmt)).first()
{% else %}
        return session.exec(stmt).first()
{% endif %}

{% endif %}
{% if 'get_or_raise' in methods %}
{% if is_async %}
    async def get_or_raise(self, session: Session, id: {{ id_type }}) -> {{ model_class }}:
{% else %}
    def get_or_raise(self, session: Session, id: {{ id_type }}) -> {{ model_class }}:
{% endif %}
        """Return a single {{ model_class }} by PK or raise NotFoundError."""
{% if is_async %}
        obj = await self.get(session, id)
{% else %}
        obj = self.get(session, id)
{% endif %}
        if obj is None:
            raise self.NotFoundError(f"{{ model_class }} not found: {id}")
        return obj

{% endif %}
{% if 'list' in methods %}
{% if is_async %}
    async def list(self, session: Session, *where, limit: int = 100, offset: int = 0) -> list[{{ model_class }}]:
{% else %}
    def list(self, session: Session, *where, limit: int = 100, offset: int = 0) -> list[{{ model_class }}]:
{% endif %}
        """Return many {{ model_class }} with pagination and optional filters."""
        stmt = select({{ model_class }})
        if where:
            stmt = stmt.where(*where)
        stmt = stmt.offset(offset).limit(limit)
{% if is_async %}
        return list((await session.exec(stmt)).all())
{% else %}
        return list(session.exec(stmt).all())
{% endif %}

{% endif %}
{% if 'find_one' in methods %}
{% if is_async %}
    async def find_one(self, session: Session, *where) -> Optional[{{ model_class }}]:
{% else %}
    def find_one(self, session: Session, *where) -> Optional[{{ model_class }}]:
{% endif %}
        """Return the first {{ model_class }} matching filters or None."""
        stmt = select({{ model_class }})
        if where:
            stmt = stmt.where(*where)
{% if is_async %}
        return (await session.exec(stmt)).first()
{% else %}
        return session.exec(stmt).first()
{% endif %}

{% endif %}
{% if 'create' in methods %}
{% if is_async %}
    async def create(self, session: Session, obj_in: {{ model_class }}) -> {{ model_class }}:
{% else %}
    def create(self, session: Session, obj_in: {{ model_class }}) -> {{ model_class }}:
{% endif %}
        """Persist a new {{ model_class }} and refresh before returning."""
        session.add(obj_in)
{% if is_async %}
    {% if commit_strategy == 'commit' %}
        await session.commit()
    {% elif commit_strategy == 'flush' %}
        await session.flush()
    {% endif %}
        await session.refresh(obj_in)
{% else %}
    {% if commit_strategy == 'commit' %}
        session.commit()
    {% elif commit_strategy == 'flush' %}
        session.flush()
    {% endif %}
        session.refresh(obj_in)
{% endif %}
        return obj_in

{% endif %}
{% if 'update' in methods %}
{% if is_async %}
    async def update(self, session: Session, db_obj: {{ model_class }}, obj_in: dict[str, Any]) -> {{ model_class }}:
{% else %}
    def update(self, session: Session, db_obj: {{ model_class }}, obj_in: dict[str, Any]) -> {{ model_class }}:
{% endif %}
        """Update an existing {{ model_class }} with provided fields and refresh."""
        for k, v in obj_in.items():
            setattr(db_obj, k, v)
        session.add(db_obj)
{% if is_async %}
    {% if commit_strategy == 'commit' %}
        await session.commit()
    {% elif commit_strategy == 'flush' %}
        await session.flush()
    {% endif %}
        await session.refresh(db_obj)
{% else %}
    {% if commit_strategy == 'commit' %}
        session.commit()
    {% elif commit_strategy == 'flush' %}
        session.flush()
    {% endif %}
        session.refresh(db_obj)
{% endif %}
        return db_obj

{% endif %}
{% if 'delete' in methods %}
{% if is_async %}
    async def delete(self, session: Session, db_obj: {{ model_class }}) -> None:
{% else %}
    def delete(self, session: Session, db_obj: {{ model_class }}) -> None:
{% endif %}
        """Delete a {{ model_class }} instance."""
        session.delete(db_obj)
{% if is_async %}
    {% if commit_strategy == 'commit' %}
        await session.commit()
    {% elif commit_strategy == 'flush' %}
        await session.flush()
    {% endif %}
{% else %}
    {% if commit_strategy == 'commit' %}
        session.commit()
    {% elif commit_strategy == 'flush' %}
        session.flush()
    {% endif %}
{% endif %}

{% endif %}
{% if 'delete_by_id' in methods %}
{% if is_async %}
    async def delete_by_id(self, session: Session, id: {{ id_type }}) -> bool:
{% else %}
    def delete_by_id(self, session: Session, id: {{ id_type }}) -> bool:
{% endif %}
        """Delete by PK and return True if removed."""
{% if is_async %}
        obj = await self.get(session, id)
{% else %}
        obj = self.get(session, id)
{% endif %}
        if not obj:
            return False
        session.delete(obj)
{% if is_async %}
    {% if commit_strategy == 'commit' %}
        await session.commit()
    {% elif commit_strategy == 'flush' %}
        await session.flush()
    {% endif %}
{% else %}
    {% if commit_strategy == 'commit' %}
        session.commit()
    {% elif commit_strategy == 'flush' %}
        session.flush()
    {% endif %}
{% endif %}
        return True

{% endif %}
{% if 'exists' in methods %}
{% if is_async %}
    async def exists(self, session: Session, *where) -> bool:
{% else %}
    def exists(self, session: Session, *where) -> bool:
{% endif %}
        """Return True if any row matches filters."""
        stmt = select({{ model_class }})
        if where:
            stmt = stmt.where(*where)
{% if is_async %}
        return (await session.exec(stmt.limit(1))).first() is not None
{% else %}
        return session.exec(stmt.limit(1)).first() is not None
{% endif %}

{% endif %}
{% if 'count' in methods %}
{% if is_async %}
    async def count(self, session: Session, *where) -> int:
{% else %}
    def count(self, session: Session, *where) -> int:
{% endif %}
        """Return the number of rows matching filters."""
        stmt = select(func.count()).select_from({{ model_class }})
        if where:
            stmt = stmt.where(*where)
{% if is_async %}
        return int((await session.exec(stmt)).scalar_one())
{% else %}
        return int(session.exec(stmt).scalar_one())
{% endif %}

{% endif %}

{% if personalize_methods %}
    # Custom repo-only stubs requested in config; remove or implement.
{% for m in personalize_methods %}
{% if is_async %}
    async def {{ m }}(self, session: Session, *args, **kwargs):
{% else %}
    def {{ m }}(self, session: Session, *args, **kwargs):
{% endif %}
        """TODO: implement custom method '{{ m }}'."""
        pass

{% endfor %}
{% endif %}
